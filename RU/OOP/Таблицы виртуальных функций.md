+ _Таблица виртуальных функций_ - это координирующая таблица - механизм, при помощи которого в языках программирования реализовано позднее связывание.
+ Является деталью реализации языка, мы обычно не не может получить к ней доступ или управлять ей.
+ В компиляторах Visual Studio называет _\_\_vfptr_ - указатель. _vftable_ - сама таблица. В литературе _vptr_ или _vtable_.

```cpp
#include <iostream>
struct Empty {};

struct EmptyVirt {
    virtual ~EmptyVirt();
};

struct NotEmpty {
    int e;
};

struct NotEmptyVirt {
    int e;
    virtual ~NotEmptyVirt();
};

struct NotEmptyNonVirt {
    void foo() const {};
    int e;
};

int main() {
    std::cout << "Empty\t" << sizeof(Empty) << std::endl; // 1
    std::cout << "EmptyVirt\t" << sizeof(EmptyVirt) << std::endl; // 8
    std::cout << "NotEmpty\t" << sizeof(NotEmpty) << std::endl; // 4
    std::cout << "NotEmptyVirt\t" << sizeof(NotEmptyVirt) << std::endl; // 16
    std::cout << "NotEmptyNonVirt\t" << sizeof(NotEmptyNonVirt) << std::endl; // 4
    std::cout << "void*\t" << sizeof(void*) << std::endl; // 8
    std::cout << "int\t" << sizeof(int) << std::endl; // 4
}
```
[тык](https://godbolt.org/z/br6a9h6aM)

+ Это плохо видно на данном примере, ведь компилятор подстраивает всё под машинное слово, но по идее добавление виртуальной функции добавляет к классу `sizeof(void*)`.
+ Добавление невиртуальной функции на размер класса не влияет


![[vtable.png]] 

У каждого класса, у которого есть виртуальные функции есть таблица виртуальных функций. Объекты каждого класса содержат *указатель на таблицу*, а не саму таблицу.

vtable это буквально таблица. Первый столбик это смещение функции, второй столбик - адрес функции.

+ Обычно компилятор кладёт указатель vptr первым скрытым полем класса.
+ Когда делается вызов виртуальной функции идём по vptr, по сдвигу определяем метод и делаем call.
+ Для всех виртуальных функций решение о вызове принимается в runtime.

