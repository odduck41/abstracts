+ _Таблица виртуальных функций_ - это координирующая таблица - механизм, при помощи которого в языках программирования реализовано позднее связывание.
+ Является деталью реализации языка, мы обычно не не может получить к ней доступ или управлять ей.
+ В компиляторах Visual Studio называет _\_\_vfptr_ - указатель. _vftable_ - сама таблица. В литературе _vptr_ или _vtable_.
+ Всегда пишем _override_ для самопроверки
+ _final_ запрещает переопределять метод или наследовать класс

```cpp
#include <iostream>
struct Empty {};

struct EmptyVirt {
    virtual ~EmptyVirt();
};

struct NotEmpty {
    int e;
};

struct NotEmptyVirt {
    int e;
    virtual ~NotEmptyVirt();
};

struct NotEmptyNonVirt {
    void foo() const {};
    int e;
};

int main() {
    std::cout << "Empty\t" << sizeof(Empty) << std::endl; // 1
    std::cout << "EmptyVirt\t" << sizeof(EmptyVirt) << std::endl; // 8
    std::cout << "NotEmpty\t" << sizeof(NotEmpty) << std::endl; // 4
    std::cout << "NotEmptyVirt\t" << sizeof(NotEmptyVirt) << std::endl; // 16
    std::cout << "NotEmptyNonVirt\t" << sizeof(NotEmptyNonVirt) << std::endl; // 4
    std::cout << "void*\t" << sizeof(void*) << std::endl; // 8
    std::cout << "int\t" << sizeof(int) << std::endl; // 4
}
```
[тык](https://godbolt.org/z/br6a9h6aM)

+ Это плохо видно на данном примере, ведь компилятор подстраивает всё под машинное слово, но по идее добавление виртуальной функции добавляет к классу `sizeof(void*)`.
+ Добавление невиртуальной функции на размер класса не влияет


![[vtable.png]] 

У каждого класса, у которого есть виртуальные функции есть таблица виртуальных функций. Объекты каждого класса содержат *указатель на таблицу*, а не саму таблицу.

vtable это буквально таблица. Первый столбик это смещение функции, второй столбик - адрес функции.

+ Обычно компилятор кладёт указатель vptr первым скрытым полем класса.
+ Когда делается вызов виртуальной функции идём по vptr, по сдвигу определяем метод и делаем call.
+ Для всех виртуальных функций решение о вызове принимается в runtime.

# Множественное наследование



Granny -> Mom -> Son <- Dad <-Granny

Son: \[ptr1]\[g]\[m]\[ptr2]\[g]\[d]\[s]..

Переопределение виртуальной функции перекрывает обе унаследованные от Granny виртуальные функции. 


Если наследование от Granny виртуальное, то 

Son: \[ptr1]\[m]..\[ptr2]\[d]\[s]\[ptr3]\[g]

|               | virtual_offset | top_offset | typeinfo      | funcs              |
| ------------- | -------------- | ---------- | ------------- | ------------------ |
| Son           | 32             | 0          | &Son typeinfo | &Son::f            |
| Dad in Son    | 16             | 16         | &Son typeinfo | Dad.f<br>&thunk    |
| Granny in Son | -              | 32         | &Son typeinfo | Granny.f<br>&thunk |

# Неочевидные проблемы с виртуальными функциями 

+ Виртуальные функции не могут быть static
+ Если виртуальная функция(не pure-virtual) не определена, то это ошибка линкера, потому что мы не можем положить пустую функцию в vtable
+ Если вызвать виртуальную функцию из конструктора(или деструктора), то она диспачится как обычная, а не как виртуальная. То есть происходит call.
+ Во время создания когда вызывается конструктор родителя vptr указывает на таблицу родителя. Когда вызывается конструктор derived, vptr перекидывает на таблицу наследника. При уничтожении всё в обратном порядке.
+ Выводится Derived 1. Аргумент по умолчанию ставиться в Compile time.
```cpp
#include <iostream>

struct Base {
	virtual void f(int x = 1) {
		std::cout << "Base " << x;
	}
}

struct Derived : Base {
	void f(int x = 2) override {
		std::cout << "Derived " << x;
	}
}

int main() {
	Derived d;
	Base& b = d;
	b.f();
}
```

+    Кринж. Если создаём указатель на родительский метод, а потом вызываем его от ребёнка, то вызывается детская перегрузка. 
```cpp
void (Mother::* p)() = &Mother::f; // 16 байт: первые 8 байт -- единица, вторые 8 байт - 0. Первое число - сдвиг относительно начала виртуальной таблицы. Второе число - сдвиг относительно начала объекта. 

Son son;
Mother& mref = son;
(mref.*p)(); // выбирается версия son.f()
```


# Ссылки

+ [почитать](https://shaharmike.com/cpp/vtable-part1/), там 4 части