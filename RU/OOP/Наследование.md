```cpp
class Unit {
  public:
	void set_hp(int hp);
	int get_hp();
	void set_mana(int mana);
	int get_mana();
  private:
	int hp_;
	int mana_;
	Model model_;
}

class Hero : public {
  public:
	void set_ms(int ms);
	int get_ms();
  private:
	int ms_, as_, armor_;
	double damage_;
	std::vector<Spell> spells_;
}

int main() {
	Unit creep;
	creep.set_hp(200);
	creep.set_mana(0);
	
	Hero lina;
	lina.set_hp(860);
	lina.set_mana(600);
	lina.set_ms(350);
}
```

# Типы наследования

| Тип наследования\\спецификатор | public    | protected | private        |
| ------------------------------ | --------- | --------- | -------------- |
| public                         | public    | protected | не наследуется |
| private                        | private   | private   | не наследуется |
| protected                      | protected | protected | не наследуется |
# Конструкторы и деструкторы

При создании derived-объекта, будет вызываться так же и base-конструктор, а при смерти - base-деструктор.
```cpp
Derived d;
/*
Base()
Derived()
~Derived()
~Base()
*/
```

В случае наследования от двух классов конструкторы вызываются в порядке в котором указаны родительские классы.

# Конструктор базового класса с параметрами

```cpp
#include <iostream>  
  
class Base1 {  
    public:  
        Base1() {  
            std::cout << "Base1()\n";  
        }  
  
        Base1(int x) : x_(x) {  
            std::cout << "Base1(int x)\n";  
        }  
  
        ~Base1() {  
            std::cout << "~Base1()\n";  
        }  
    private:  
        int x_;  
};  
  
class Base2 {  
    public:  
        Base2() {  
            std::cout << "Base2()\n";  
        }  
  
        Base2(int y) : y_(y) {  
            std::cout << "Base2(int y)\n";  
        }  
  
        ~Base2() {  
            std::cout << "~Base2()\n";  
        }  
    private:  
        int y_;  
};  
  
class Derived : public Base1, public Base2 {  
    public:  
        Derived() {  
            std::cout << "Derived()\n";  
        }  
  
        Derived(int z) : z_(z) {  
            std::cout << "Derived(int z)\n";  
        }  
  
        Derived(int x, int z) : Base1(x), z_(z) {  
            std::cout << "Derived(int x, int z)\n";  
        }  
  
        Derived(int y, int z, std::string) : Base1(y), z_(z) {  
            std::cout << "Derived(int y, int z, std::string)\n";  
        }  
  
        Derived(int x, int y, int z) : Base1(x), Base2(y), z_(z) {  
            std::cout << "Derived(int x, int y, int z)\n";  
        }  
  
        ~Derived() {  
            std::cout << "~Derived()\n";  
        }  
    private:  
        int z_;  
};  
  
int main() {  
	// чё смотришь, запусти и сам посоздавай объектов
}
```

Если есть конструктор по умолчанию у базового класса, то дочерний вызовет его, иначе он будет пытаться вызвать другой конструктор, но у другого скорее всего будут какие-то параметры, значит мы их должны передать. 
### Мораль
+ Конструктор дочернего класса должен принимать параметры, чтобы передать их «транзитом» вверх суперклассам, ДАЖЕ ЕСЛИ У НЕГО НЕ ЗАДУМЫВАЛИСЬ СВОИ ПАРАМЕТРЫ
+ После двоеточия можно звать конструкторы суперклассов и заполнять свои поля
+ Зовём всё в ТОМ ПОРЯДКЕ, В КОТОРОМ ОНО НАСЛЕДУЕТСЯ(ИЛИ ОБЪЯВЛЯЕТСЯ). Подробнее - [тут](https://stackoverflow.com/questions/24285112/why-must-initializer-list-order-match-member-declaration-order)

К полям и методам класса родителя можно обращаться так: `d.Base1::`, `::` - операция разрешения контекста. 


![[russian doll.png]]

![[pizdez.png]]

Ссылки(я надеюсь, что они бесконечны):
https://godbolt.org/z/zvrxYacrc
