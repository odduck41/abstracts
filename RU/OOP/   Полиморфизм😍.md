## Проблема

```cpp
class Base { 
	public:
		int x_;
}; 

class A : public Base {}; 

class B : public Base {}; 

class Derived : public A, public B {};

int main() {
	Derived garbage; std::cout << garbage.x_; // x_ is ambiguous
}
```

### Первый способ решения

```cpp
	std::cout << garbage.A::x_ << std::endl;
	std::cout << garbage.B::x_ << std::endl;
```
Операция разрешения контекста

### Второй способ
#### Виртуальное наследование

```cpp
class Base { 
	public:
		int x_;
}; 

class A : virtual public Base {}; 

class B : virtual public Base {}; 

class Derived : public A, public B {};

int main() {
	Derived object; std::cout << object.x_ << object.A::x_ << object.B::x_;
	// x_ везде одинаков
}
```

_Виртуальное наследование_ - гарантирует, что у наследников данного класса(который тоже от чего-то наследуется) будет ровно одна копия всех полей и методов

# Полиморфизм

_Полиморфизм_ - способность функции обрабатывать данные разных типов.

## Общая теория
_(Кристофер Стрэчи, Fundamental Concepts in Programming Languages, 1967)_

Полиморфизм бывает двух типов:
+ Параметрический - тип не упоминается, одинаковый код
	+ Приведение к/из `void*`(техника забывания типа)
+ Ad-hoc - для разных несовместимых типов разный код под единым интерфейсом
	+ Бесконечные перегрузки функций
	+ Приведение типов
	+ Наследование 
	+ Шаблоны

>Один интерфейс - много реализаций
_Бьерн Страуструп_


## Полиморфизм по Страуструпу

Полиморфизм:
+ Статический(early biding) - знаем, какая реализация будет работать в compile-time
	+ Перегрузка функций
	+ Приведение типов
	+ Раскрытие шаблонов
+ Динамический(late biding) - установить реализацию в compile time невозможно, она устанавливается в runtime
	+ Наследование(виртуальные функции и произвольные типы)

# Указатели на производные типы

Указатель на базовый класс может ссылаться на любой объект выведенный из этого класса.
Наоборот неверно!

## Принцип работы
```cpp
class A {};
class B : public A {};

A* a_ptr;
A a;
B b;

a_ptr = &a;
a_ptr = &b; // нет доступа к полям и методам B(уточнениям A)
```

Чтобы получить доступ к членам наследника надо скастить его к наследнику.

```cpp
((B*)a_ptr)->bMethod();
static_cast<B*>(a_ptr)->bMethod();
```

Аналогично можно сделать в обратную сторону:
```cpp
((A*) b_ptr)->aMethod();
static_cast<A*>(b_ptr)->aMethod();
```

Ссылки на производные типы работают так же. Часто используется в функциях. Параметр, который имеет тип ссылки на базовый класс, может принимать объекты как базового класса, так и его наследников.

# Виртуальные функции

+ _Виртуальный метод_ - метод класса, который может быть переопределён в классах-наследниках так, что конкретная реализация метода для вызова будет определяться во время исполнения.
+ Помечается как `virtual`. При переопределении писать уже не нужно, но можно.
+ Исполняемый код зависит от **типа** объекта, но не указателя. Является обычной функцией, не обязательно звать только через указатель.
+ Класс, который включает в себя виртуальную функцию, называется _полиморфным классом_.
+ Полиморфным так же является и наследуемый от полиморфного класс.

## Пример

```cpp
class Base { 
  public: 
	virtual void who() { 
		std::cout << "Base\n"; 
	}
}; 

class Derived1 : public Base { 
  public: 
	void who() { 
		std::cout << "Derived1\n"; 
	}
};

class Derived2 : public Base {
  public: 
	void who() { 
		std::cout << "Derived2\n"; 
	} 
};

Base b;
Derived1 d1;
Derived2 d2;

Base* ptr = &b;
ptr->who();
ptr = &d1;
ptr->who();
ptr = &d2;
ptr->who();
```

Если уберём `virtual`, то получим три Base, оставив получим: "Base Derived1 Derived2".
\
+ Если виртуальная функция переопределяется в производном классе, то её называют _переопределённой_. 
+ Виртуальная функция может быть `friend` для другого класса


_Принцип иерархичности_ - идём вверх по стрелочкам в графе наследования, пока не найдём ближайшую реализацию метода

+ Конструкторы не могут быть виртуальными. 
+ Деструкторы могут быть виртуальными.
+ Виртуальный деструктор полиморфного класса гарантирует, что будет вызван корректный деструктор.
